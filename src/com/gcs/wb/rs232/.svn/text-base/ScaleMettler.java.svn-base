/*
 * This driver is written for Openbravo POS to communicate with Mettler Scales
 * The Protocol used on Mettler scales is: MT - SICS
 * ScaleSamsungEsp.java modified by Shameer C K, shameerck@gmail.com
 * 12/24/2009
 *
 *
 */
package com.gcs.wb.rs232;

import com.gcs.wb.rs232.exceptions.IllegalPortException;
import gnu.io.CommPort;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.TooManyListenersException;

import gnu.io.CommPortIdentifier;
import gnu.io.NoSuchPortException;
import gnu.io.PortInUseException;
import gnu.io.SerialPort;
import gnu.io.SerialPortEvent;
import gnu.io.SerialPortEventListener;
import gnu.io.UnsupportedCommOperationException;
import java.math.BigInteger;
import java.util.HashMap;
import javax.swing.JFormattedTextField;
import org.apache.log4j.Logger;

public class ScaleMettler implements SerialPortEventListener {

    private String portName = null;
    private Integer speed = null;
    private Short dataBits = null;
    private Short stopBits = null;
    private Short parity = null;
    private JFormattedTextField control = null;
    private CommPortIdentifier portIdentifier = null;
    private CommPort commPort = null;
    private SerialPort serialPort;
    private OutputStream out;
    private InputStream in;
    private int count = 0;
    private StringBuilder buffer = new StringBuilder();

    /** Creates a new instance of ScaleComm */
    public ScaleMettler(String portName, Integer speed, Short dataBits, Short stopBits, Short parity, JFormattedTextField control) {
        this.portName = portName;
        this.speed = speed;
        this.dataBits = dataBits;
        this.stopBits = stopBits;
        this.parity = parity;
        this.control = control;
    }

    public void connect() throws PortInUseException, NoSuchPortException, UnsupportedCommOperationException, IOException, TooManyListenersException, IllegalPortException {
        if (out == null) {
            try {
                portIdentifier = CommPortIdentifier.getPortIdentifier(portName);
            } catch (NoSuchPortException ex) {
                Logger.getLogger(ScaleMettler.class.getName()).error(ex.getLocalizedMessage(), ex);
                throw ex;
            }
            if (portIdentifier.isCurrentlyOwned()) {
                String msg = "Error: Port " + portName + " is currently in use";
                Logger.getLogger(ScaleMettler.class.getName()).error(msg);
                throw new PortInUseException();
            } else {

                commPort = portIdentifier.open(this.getClass().getName() + "_" + commPort, 2000);
                if (commPort instanceof gnu.io.SerialPort) {
                    try {
                        serialPort = (SerialPort) commPort;
                        serialPort.setSerialPortParams(speed.intValue(), dataBits.intValue(), stopBits.intValue(), parity.intValue());
                        in = serialPort.getInputStream();
                        out = serialPort.getOutputStream();
                        serialPort.addEventListener(this);
                        serialPort.notifyOnDataAvailable(true);
                        //String msg = "Data already";
                        //Logger.getLogger(ScaleMettler.class.getName()).error(msg);
                        //throw new IllegalPortException(msg);

                    } catch (UnsupportedCommOperationException ex) {
                        Logger.getLogger(ScaleMettler.class.getName()).error(null, ex);
                        throw ex;
                    } catch (IOException ex) {
                        Logger.getLogger(ScaleMettler.class.getName()).error(null, ex);
                        throw ex;
                    } catch (TooManyListenersException ex) {
                        Logger.getLogger(ScaleMettler.class.getName()).error(null, ex);
                        throw ex;
                    }
                } else {
                    String msg = "Error: Only serial ports are handled by this example.";
                    Logger.getLogger(ScaleMettler.class.getName()).error(msg);
                    throw new IllegalPortException(msg);
                }
            }
        }
        write(new byte[]{0x53}); //S
        write(new byte[]{0x0D}); //S
        write(new byte[]{0x0A}); //S
        flush();
    }

    private void flush() {
        try {
            out.flush();
        } catch (IOException e) {
        }
    }

    private void write(byte[] data) {
        try {
            out.write(data);
        } catch (IOException ex) {
            Logger.getLogger(ScaleMettler.class.getName()).error(null, ex);
        }
    }

//    @SuppressWarnings("element-type-mismatch")
    @Override
    public void serialEvent(SerialPortEvent e) {
        HashMap<Character, String> numbers = new HashMap<Character, String>();
        String remove_string = "00000010";
        for (int i = 0; i < 10; i++) {
            numbers.put(String.valueOf(i).charAt(0), String.valueOf(i));
        }
        switch (e.getEventType()) {
            case SerialPortEvent.BI:
            case SerialPortEvent.OE:
            case SerialPortEvent.FE:
            case SerialPortEvent.PE:
            case SerialPortEvent.CD:
            case SerialPortEvent.CTS:
            case SerialPortEvent.DSR:
            case SerialPortEvent.RI:
            case SerialPortEvent.OUTPUT_BUFFER_EMPTY:
                break;
            case SerialPortEvent.DATA_AVAILABLE:
                try {
                    while (in.available() > 0) {
                        int b = in.read();
                        if (b == 0x000D || b == 0x002E || !(b > 0x002F && b < 0x003A)) {
                            continue;
                        }
                        Character c = (char) b;
                        String val = numbers.get(c);
                        if (val == null) {
                            continue;
                        }
                        buffer.append(val);
                        String strVal = buffer.toString().trim();
                        int found = strVal.indexOf(remove_string);
                        if (found > 0) {
                            count++;
                            int bIdx = found - 6;
                            if (bIdx >= 0) {
                                strVal = strVal.substring(bIdx, found);
                                BigInteger intVal = new BigInteger(strVal);
                                control.setValue(intVal);
                                buffer = new StringBuilder();
                                strVal = null;
                            }
                        }
                    }
                } catch (IOException ex) {
                    Logger.getLogger(ScaleMettler.class.getName()).error(null, ex);
                }
                break;
        }
    }

    public void disconnect() throws IOException {
        if (in != null) {
            try {
                in.close();
            } catch (IOException ex) {
                Logger.getLogger(ScaleMettler.class.getName()).error(null, ex);
                throw ex;
            }
        }
        if (out != null) {
            try {
                out.close();
            } catch (IOException ex) {
                Logger.getLogger(ScaleMettler.class.getName()).error(null, ex);
                throw ex;
            }
        }
        if (commPort != null) {
            commPort.close();
        }
        if (serialPort != null) {
            serialPort.close();
        }
    }
}
